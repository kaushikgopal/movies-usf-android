package co.kaush.usf

import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.distinctUntilChanged
import kotlinx.coroutines.flow.filterNotNull
import kotlinx.coroutines.flow.flatMapConcat
import kotlinx.coroutines.flow.flatMapMerge
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.flow.scan
import kotlinx.coroutines.flow.shareIn
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

/**
 * When building features, we create <Feature>ViewModelImpl.kt classes that extend this class. and
 * only implement the relevant parts of the feature. All boilerplate code is handled by
 * [UsfViewModelImpl] & the corresponding <Feature>UsfViewModel] class generated by the annotation
 * processor.
 */
@OptIn(ExperimentalCoroutinesApi::class)
abstract class UsfViewModelImpl<E : Any, R : Any, VS : Any, Effect : Any>(
  initialState: VS,
  private val coroutineScope: CoroutineScope,
  private val processingDispatcher: CoroutineDispatcher = Dispatchers.IO,
  logger: UsfVmLogger =
      object : UsfVmLogger {
        val tag = Thread.currentThread().stackTrace[4].className.split(".").last()
        override fun debug(message: String) = run { /*do something*/ }
        override fun warning(message: String) = run { /*do something*/ }
        override fun error(error: Throwable, message: String) = run { /*do something*/ }
      }
) : UsfVm<E, VS, Effect> {

  /**
   * @param event every input is processed into an [E]vent
   * @return [Flow]<[R]> a single [E]vent can result in multiple [R]esults for e.g. emit a R for
   *   loading and another for the actual result
   */
  protected abstract fun eventToResultFlow(event: E): Flow<R>

  /**
   * @param currentViewState the current [VS]tate of the view (.copy it for the returned [VS]tate)
   * @return [VS]tate Curiously, we don't return a [Flow]<[VS]> here every [R]esult will only ever
   *   be transformed into a single [VS]tate if you want multiple [VS]tates emit multiple [R]esults
   *   transforming each [R]esult to the respective [VS]tate
   */
  protected abstract fun resultToViewState(currentViewState: VS, result: R): VS

  /**
   * @param result a single [R]esult can result in multiple [Effect]s for e.g. emit a VE for
   *   navigation and another for an analytics call hence a return type of [Flow]<[Effect]>
   * @return [Flow] of [Effect]s where null emissions will be ignored automatically
   */
  protected abstract fun resultToEffects(result: R): Flow<Effect?>

  /**
   * we use a "shared" flow vs state flow here to avoid conflation of state flows.
   *
   * every single event needs to reach the view model as they could have important implications to
   * the VM logic state flow might conflate multiple events if they happen simultaneously.
   */
  private val _events =
      MutableSharedFlow<E>(
          /**
           * we do this to prevent a race condition misfire for events sent in very early. for e.g.
           * OnScreenLoad events that are sent via [processInput()] right after the VM is created
           * can get ignored as .collect(ion) has started yet.
           *
           * inside the init block, we "launch" (which is fire and forget with coroutines) so the VM
           * proceeds to "finish" initialization and allows the Screen/Fragment/Activity to send
           * inputs to the "hot" _events flow which will drop it, since noone is listening.
           *
           * Adding a replay ensures that the first event is always sent to "new" subscribers.

          replay = 1, */
      )

  private val _results = _events
      .flatMapMerge(concurrency = 5) { event ->
        logger.debugEvents(event)
        eventToResultFlow(event)
      }
      .onEach { logger.debugResults(it) }

  override val effects = _results
      .flatMapConcat { resultToEffects(it).filterNotNull() }
      .onEach { logger.debugSideEffects(it) }
      .shareIn(coroutineScope, SharingStarted.WhileSubscribed())

  override val viewState = _results
      .scan(initialState) { vs, result ->
        resultToViewState(vs, result)
      }
      .distinctUntilChanged()
      .onEach { logger.debugViewState(it) }
      .stateIn(coroutineScope, SharingStarted.WhileSubscribed(), initialState)


  init {
    logger.debug("------ [init] ${Thread.currentThread().name}")
  }

  override fun processInput(event: E) {
    coroutineScope.launch(processingDispatcher) { _events.emit(event) }
  }

  interface UsfVmLogger {
    fun debug(message: String)

    fun debugEvents(event: Any, message: String? = null) =
        debug(message ?: "----- [event] ${Thread.currentThread().name} $event")

    fun debugResults(result: Any, message: String? = null) =
        debug(message ?: "----- [result] ${Thread.currentThread().name} $result")

    fun debugViewState(viewState: Any, message: String? = null) =
        debug(message ?: "----- [view-state] ${Thread.currentThread().name} $viewState")

    fun debugSideEffects(effect: Any, message: String? = null) =
        debug(message ?: "----- [effect] ${Thread.currentThread().name} $effect")

    fun warning(message: String)

    fun error(error: Throwable, message: String)
  }
}
