package co.kaush.msusf.usf

import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import timber.log.Timber

/**
 * When building features, we create <Feature>ViewModelImpl.kt classes that extend this class. and
 * only implement the relevant parts of the feature. All boilerplate code is handled by
 * [UsfViewModelImpl] & the corresponding <Feature>UsfViewModel] class generated by the annotation
 * processor.
 */
@OptIn(ExperimentalCoroutinesApi::class)
abstract class UsfViewModelImpl<E : Any, R : Any, VS : Any, Effect : Any>(
    initialState: VS,
    private val coroutineScope: CoroutineScope,
    private val processingDispatcher: CoroutineDispatcher = Dispatchers.IO,
    logger: UsfVmLogger =
        object : UsfVmLogger {
          val tag = Thread.currentThread().stackTrace[4].className.split(".").last()
          override fun debug(message: String) = Timber.tag(tag).d(message)
          override fun warning(message: String) = Timber.tag(tag).w(message)
          override fun error(error: Throwable, message: String) = Timber.tag(tag).e(error, message)
        }
) : UsfVm<E, VS, Effect> {

  /**
   * @param event every input is processed into an [E]vent
   * @return [Flow]<[R]> a single [E]vent can result in multiple [R]esults for e.g. emit a R for
   *   loading and another for the actual result
   */
  protected abstract suspend fun eventToResultFlow(event: E): Flow<R>

  /**
   * @param currentViewState the current [VS]tate of the view (.copy it for the returned [VS]tate)
   * @return [VS]tate Curiously, we don't return a [Flow]<[VS]> here every [R]esult will only ever
   *   be transformed into a single [VS]tate if you want multiple [VS]tates emit multiple [R]esults
   *   transforming each [R]esult to the respective [VS]tate
   */
  protected abstract suspend fun resultToViewState(currentViewState: VS, result: R): VS

  /**
   * @param result a single [R]esult can result in multiple [Effect]s for e.g. emit a VE for
   *   navigation and another for an analytics call hence a return type of [Flow]<[Effect]>
   * @return [Flow] of [Effect]s where null emissions will be ignored automatically
   */
  protected abstract suspend fun resultToEffects(result: R): Flow<Effect?>

  /**
   * we use a "shared" flow vs state flow here to avoid conflation of state flows.
   *
   * every single event needs to reach the view model as they could have important implications to
   * the VM logic state flow might conflate multiple events if they happen simultaneously.
   */
  private val _events =
      MutableSharedFlow<E>(
          /**
           * we do this to prevent a race condition misfire for events sent in very early. for e.g.
           * OnScreenLoad events that are sent via [processInput()] right after the VM is created
           * can get ignored as .collect(ion) has started yet.
           *
           * inside the init block, we "launch" (which is fire and forget with coroutines) so the VM
           * proceeds to "finish" initialization and allows the Screen/Fragment/Activity to send
           * inputs to the "hot" _events flow which will drop it, since noone is listening.
           *
           * Adding a replay ensures that the first event is always sent to "new" subscribers.
           */
          replay = 1)
  private val _viewState = MutableStateFlow(initialState)

  /**
   * we use a "shared" flow vs state flow here to avoid conflation of state flows.
   *
   * every effect must be sent out and cannot be ignored even if there are multiple side effects
   * emitted quickly/simultaneously as that could have implications to the Screen logic
   *
   * there are times where we _want_ to ignore certain effects (like multiple loading spinner calls)
   * these can be handled in the Results emission layer.
   */
  private val _effects = MutableSharedFlow<Effect>()

  override val viewState = _viewState.asStateFlow()
  override val effects = _effects.asSharedFlow()

  init {
    logger.debug("------ [init] ${Thread.currentThread().name}")

    coroutineScope.launch(processingDispatcher) {
      _events
          .flatMapMerge { event ->
            logger.debugEvents(event)
            eventToResultFlow(event)
          }
          .collect { result ->
            logger.debugResults(result)

            // StateFlow already behaves as if distinctUntilChanged operator is applied to it
            resultToViewState(_viewState.value, result).let { vs ->
              logger.debugViewState(vs)
              _viewState.emit(vs)
            }

            // effects are emitted after a view state by virtue of this collect call
            // (rarely) would we want VS & VE to be emitted at the exact same instant
            _effects.emitAll(
                resultToEffects(result).filterNotNull().onEach { logger.debugSideEffects(it) },
            )
          }
    }
  }

  override fun processInput(event: E) {
    coroutineScope.launch(processingDispatcher) { _events.emit(event) }
  }

  interface UsfVmLogger {
    fun debug(message: String)

    fun debugEvents(event: Any, message: String? = null) =
        debug(message ?: "----- [event] ${Thread.currentThread().name} $event")

    fun debugResults(result: Any, message: String? = null) =
        debug(message ?: "----- [result] ${Thread.currentThread().name} $result")

    fun debugViewState(viewState: Any, message: String? = null) =
        debug(message ?: "----- [view-state] ${Thread.currentThread().name} $viewState")

    fun debugSideEffects(effect: Any, message: String? = null) =
        debug(message ?: "----- [effect] ${Thread.currentThread().name} $effect")

    fun warning(message: String)

    fun error(error: Throwable, message: String)
  }
}
